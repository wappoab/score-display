<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Display Client</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        
        #resultFrame {
            width: 100%;
            height: 100%;
            border: none;
            display: block;
        }

        #timerOverlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 20vw;
            font-weight: bold;
            display: none; /* Hidden by default */
            z-index: 9999;
        }

        .active { display: flex !important; }
    </style>
</head>
<body>
    <iframe id="resultFrame" src="about:blank"></iframe>
    <div id="timerOverlay">00:00</div>
    <div id="statusIndicator" style="position: absolute; bottom: 10px; right: 10px; color: white; font-family: sans-serif; background: rgba(0,0,0,0.8); padding: 10px; z-index: 10000; border: 1px solid #444;">
        Booting...
    </div>

    <script>
        let config = null;
        let ws = null;
        let reconnectDelay = 3000;
        const maxReconnectDelay = 30000;

        function closeWebSocket() {
            if (ws) {
                ws.onclose = null;
                ws.onerror = null;
                ws.onmessage = null;
                ws.onopen = null;
                ws.close();
                ws = null;
            }
        }

        async function init() {
            const status = document.getElementById('statusIndicator');
            if (!status) {
                console.error("Status element not found!");
                return;
            }
            
            status.style.display = 'block';
            status.innerText = "System Started. Waiting for Server...";
            console.log("Init started...");

            try {
                // Poll for configuration until Server is found
                let retryCount = 0;
                while (true) {
                    try {
                        const cfgReq = await fetch('/config');
                        if (cfgReq.ok) {
                            config = await cfgReq.json();
                            if (config.connected && config.wsUrl) {
                                break; // Server found!
                            }
                        }
                    } catch (e) {
                        console.log("Local config fetch failed, retrying...");
                    }
                    retryCount++;
                    status.innerText = `Waiting for Server (Attempt ${retryCount})...`;
                    await new Promise(r => setTimeout(r, 2000));
                }

                // Close any existing WebSocket before creating new one
                closeWebSocket();

                status.innerText = "Connecting to " + config.wsUrl;
                console.log("Connecting to Server at:", config.wsUrl);
                ws = new WebSocket(config.wsUrl);

                ws.onopen = () => {
                    console.log("WS Connected");
                    reconnectDelay = 3000; // Reset backoff on successful connection
                    status.style.color = "lime";
                    status.innerText = "Connected: " + config.clientName;
                    setTimeout(() => status.style.display = 'none', 5000); // Hide after 5s
                    document.title = config.clientName;
                    ws.send(JSON.stringify({
                        type: "handshake",
                        payload: { name: config.clientName, id: config.clientName }
                    }));
                };

                ws.onmessage = (event) => {
                    let msg;
                    try {
                        msg = JSON.parse(event.data);
                    } catch (e) {
                        console.error("Failed to parse message:", event.data, e);
                        return;
                    }
                    handleMessage(msg);
                };

                ws.onclose = () => {
                    console.log("WS Closed. Retrying in " + reconnectDelay + "ms...");
                    status.style.display = 'block';
                    status.style.color = 'red';
                    status.innerText = "Disconnected. Retrying...";
                    setTimeout(init, reconnectDelay);
                    // Exponential backoff
                    reconnectDelay = Math.min(reconnectDelay * 1.5, maxReconnectDelay);
                };

                ws.onerror = (error) => {
                    console.error("WebSocket error:", error);
                };

            } catch (e) {
                console.error("Failed to init:", e);
                setTimeout(init, 2000);
            }
        }

        function handleMessage(msg) {
            console.log("Rx Message:", msg.type, msg.payload);
            const overlay = document.getElementById('timerOverlay');
            const status = document.getElementById('statusIndicator');
            const iframe = document.getElementById('resultFrame');
            
            if (msg.type === "timer_update") {
                const state = msg.payload;
                const m = Math.floor(state.timeLeft / 60).toString().padStart(2, '0');
                const s = (state.timeLeft % 60).toString().padStart(2, '0');
                overlay.innerText = `${m}:${s}`;
            } else if (msg.type === "display_mode") {
                if (msg.payload === "show_timer") {
                    overlay.classList.add("active");
                    iframe.style.visibility = 'hidden';
                    iframe.style.opacity = '0';
                } else {
                    overlay.classList.remove("active");
                    iframe.style.visibility = 'visible';
                    iframe.style.opacity = '1';
                }
            } else if (msg.type === "set_result") {
                const url = config.serverBaseUrl + "/results/" + msg.payload.file;
                iframe.src = url;
            } else if (msg.type === "update_config") {
                if (msg.payload.key === "ClientName") {
                    const newName = msg.payload.value;
                    document.title = newName;
                    
                    // Persist to Go backend
                    fetch('/config/update', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ clientName: newName })
                    }).then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        config.clientName = newName;
                        ws.send(JSON.stringify({
                            type: "handshake",
                            payload: { name: newName, id: newName }
                        }));
                    }).catch(err => {
                        console.error("Failed to update config:", err);
                    });
                }
            }
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>